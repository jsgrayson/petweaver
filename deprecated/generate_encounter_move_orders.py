# generate_encounter_move_orders.py
"""
Generate a markdown file that lists, for every NPC (tamer) in encounters_full.json,
the *preferred* order of abilities each pet would use according to the priority
system (Swap > Priority > Speed > Coin‑flip).  This is a static ordering – it does
not simulate buffs or dynamic speed changes, but it gives a deterministic view
that the AI can start from.

The script:
1. Loads `encounters_full.json` (generated by generate_full_tamer_encounters.py).
2. For each NPC, iterates over its pets.
3. For each pet, sorts its abilities by:
   * `ability.priority` (higher first, swaps are priority = inf in the data).
   * `effective_speed = pet.base_speed + ability.speed` – we approximate base
     speed as the pet's `speed` stat (if present) or 0.
   * Ties are marked as "random" (coin‑flip).
4. Writes a markdown file `npc_encounter_move_orders.md` with a section per NPC
   and a table of `Pet → Ability → Priority → Speed → Note`.

The generated markdown can be used by the AI decision‑tree to pick the best
counter‑ability for each encounter.
"""
import json
import os
from pathlib import Path

# Paths
PROJECT_ROOT = Path(__file__).resolve().parent
ENCounters_PATH = PROJECT_ROOT / "encounters_full.json"
OUTPUT_MD = PROJECT_ROOT / "npc_encounter_move_orders.md"

def load_encounters():
    with open(ENCounters_PATH, "r", encoding="utf-8") as f:
        return json.load(f)

def effective_speed(pet, ability):
    # The simulator calculates speed as pet.get_effective_speed() + ability.speed.
    # Here we approximate pet speed with the 'speed' field of the pet (if any).
    base_speed = pet.get("speed", 0)  # many pets have speed 0 in the data
    return base_speed + ability.get("speed", 0)

def sort_abilities(pet):
    abilities = pet.get("abilities", [])
    # Assign a very high priority for swaps (they are represented as a special
    # ability with a flag; in the data we treat any ability named "Swap" as
    # priority = 9999).  Most abilities have a numeric `priority` field.
    def ability_key(ab):
        # Higher priority first, then higher speed.
        prio = ab.get("priority", 0)
        if ab.get("name", "").lower() == "swap":
            prio = 9999
        spd = effective_speed(pet, ab)
        return (-prio, -spd)
    # Stable sort so that ties keep original order (useful for coin‑flip note).
    sorted_abs = sorted(abilities, key=ability_key)
    return sorted_abs

def generate_markdown(encounters):
    lines = ["# NPC Encounter Move‑Order Reference (Static Priority)\n\n"]
    for npc in encounters:
        npc_id = npc.get("npc_id")
        name = npc.get("name", "Unknown")
        lines.append(f"## {name} (ID {npc_id})\n")
        lines.append("| Pet (Species ID) | Ability | Priority | Speed (approx.) | Note |\n|---|---|---|---|---|\n")
        for pet in npc.get("pets", []):
            species_id = pet.get("species_id")
            pet_label = f"Pet {species_id}"
            sorted_abs = sort_abilities(pet)
            for i, ab in enumerate(sorted_abs):
                name_ab = ab.get("name", "?")
                prio = ab.get("priority", 0)
                if name_ab.lower() == "swap":
                    prio = "Swap"
                spd = effective_speed(pet, ab)
                note = "" if i == 0 else "(later)"
                lines.append(f"| {pet_label} | {name_ab} | {prio} | {spd} | {note} |\n")
        lines.append("\n")
    return "".join(lines)

def main():
    encounters = load_encounters()
    md_content = generate_markdown(encounters)
    with open(OUTPUT_MD, "w", encoding="utf-8") as f:
        f.write(md_content)
    print(f"✅ Generated {OUTPUT_MD} with move‑order tables for {len(encounters)} NPCs.")

if __name__ == "__main__":
    main()
